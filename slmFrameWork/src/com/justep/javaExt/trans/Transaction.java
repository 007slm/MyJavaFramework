package com.justep.javaExt.trans;

import java.sql.Connection;

import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Savepoint;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;

import com.justep.javaExt.dao.DbUtils;
/**
 * 关于数据库的事务类
 * @author 007slm
 *
 * 设计原理：
 *      1.一个线程应该只有一个线程在启动中，嵌套的事务是被外面的事务所包含吃掉的
 *      2.事务是可以嵌套的
 *      3.用户不需要主动声明事务（由我自己判断什么时候需要事务的开启），所以是私有的构造函数
 *      4.不支持跨线程的事务
 *      
 *      <config name="dataSource" value="oracle.jdbc.driver.OracleDriver;jdbc:oracle:thin:@192.168.1.19:1521:oracle73;x5_dev;1"/>
		<config name="dataSource" value="java:comp/env/system"/>
		可以看到上面的用的jdbc直连 ，不需要tomcat特殊配置，下面的用的jndi的方式 ，需要tomcat配置jndi，这样的话 能用到tomcat的dbcp连接池
 *      
 */
public class Transaction {
	protected Transaction(){
		
	}
	
	private HashMap<String,JtaConnection> conns=new HashMap<String,JtaConnection>();
	
	
	
	public JtaConnection getConnection(String jndiName) throws SQLException,NamingException{
		JtaConnection jtaConn = conns.get(jndiName);
		if (jtaConn==null) {
			jtaConn = new JtaConnection(jndiName, DbUtils.getConnection(jndiName));
			conns.put(jndiName, jtaConn);
		}
		return jtaConn;
	}
	
	
	
	
	void begin() {
		
	}
	
	void commit() throws SQLException{
		/**
		 * 事务提交的时候 
		 * 	1.提交当前事务下的所有connection
		 * 	2.connection的commit的状态回复在connection的close方法中
		 */
		
		for (JtaConnection con : conns.values()) {
			con.conn.commit();
		}
	}
	
	void rollback() throws SQLException{
		for (JtaConnection con : conns.values()) {
			con.conn.rollback();
		}
	}
	
	void clear() throws SQLException{
		for(JtaConnection con : conns.values()){
			System.out.println("关闭con"+con);
			con.close();
			
		}
		conns.clear();
	}
	
	
		
	private class JtaConnection extends ConnectionWapper{
		
		private Connection conn;
		private String jndiName;
		private boolean autoCommit =true;
		
		private List<Statement> statementList =new ArrayList<Statement>();
		
		
		JtaConnection(String jndiName,Connection conn){
			super(conn);
			try {
				autoCommit=conn.getAutoCommit();
				conn.setAutoCommit(false);
			} catch (SQLException e) {
				e.printStackTrace();
			}
			this.jndiName=jndiName;
			this.conn=conn;
			
		}


		@Override
		public void close() throws SQLException {
			
			conns.remove(jndiName);
			/**
			 * 同时关闭这个connection上关闭的所有资源
			 * 当关闭stmt的时候 ，通过stmt自动产生的resultSet也会自动关闭
			 */
			for (Iterator<Statement> iterator = statementList.iterator(); iterator.hasNext();) {
				Statement stmt = (Statement) iterator.next();
				System.out.println("关闭stmt"+stmt);
				stmt.close();
			}
			statementList.clear();
			this.conn.setAutoCommit(autoCommit);
			super.close();
		}
		
		@Override
		public Statement createStatement() throws SQLException {
			Statement stmt =super.createStatement();
			statementList.add(stmt);
			return stmt;
		}
		
		@Override
		public PreparedStatement prepareStatement(String sql)
				throws SQLException {
			PreparedStatement preStmt =super.prepareStatement(sql);
			statementList.add(preStmt);
			return preStmt;
		}
		
		@Override
		public PreparedStatement prepareStatement(String sql,
				int resultSetType, int resultSetConcurrency)
				throws SQLException {
			PreparedStatement preStmt =super.prepareStatement(sql, resultSetType, resultSetConcurrency);
			statementList.add(preStmt);
			return preStmt;
		}
		
		@Override
		public PreparedStatement prepareStatement(String sql,
				int autoGeneratedKeys) throws SQLException {
			PreparedStatement preStmt =super.prepareStatement(sql, autoGeneratedKeys);
			statementList.add(preStmt);
			return preStmt;
		}
		
		@Override
		public PreparedStatement prepareStatement(String sql,
				String[] columnNames) throws SQLException {
			PreparedStatement preStmt =super.prepareStatement(sql, columnNames);
			statementList.add(preStmt);
			return preStmt;
		}
		
		@Override
		public boolean isClosed() throws SQLException {
			return this.conn == null || this.conn.isClosed();
		}

		@Override
		public void commit() throws SQLException {
			throw new SQLException("JTA事务下不支持Connection上的commit!");
		}

		@Override
		public int getTransactionIsolation() throws SQLException {
			throw new SQLException("JTA事务下不支持Connection上的getTransactionIsolation!");
		}

		@Override
		public void releaseSavepoint(Savepoint savepoint) throws SQLException {
			throw new SQLException("JTA事务下不支持Connection上的releaseSavepoint!");
		}

		@Override
		public void rollback() throws SQLException {
			throw new SQLException("JTA事务下不支持Connection上的rollback!");
		}

		@Override
		public void rollback(Savepoint savepoint) throws SQLException {
			throw new SQLException("JTA事务下不支持Connection上的rollback!");
		}

		@Override
		public void setAutoCommit(boolean autoCommit) throws SQLException {
			throw new SQLException("JTA事务下不支持Connection上的setAutoCommit!");
		}

		@Override
		public Savepoint setSavepoint() throws SQLException {
			throw new SQLException("JTA事务下不支持Connection上的setSavepoint!");
		}

		@Override
		public Savepoint setSavepoint(String name) throws SQLException {
			throw new SQLException("JTA事务下不支持Connection上的setSavepoint!");
		}

		@Override
		public void setTransactionIsolation(int level) throws SQLException {
			throw new SQLException("JTA事务下不支持Connection上的setTransactionIsolation!");
		}
	}	
}
